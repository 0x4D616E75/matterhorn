
This one will just need to iterate over all teams to stop all Aspell
instances once we start one for each team:
src/Matterhorn/App.hs:91:    case finalSt^.csCurrentTeam.tsEditState.cedSpellChecker of

Needs to use the team that the channel cId belongs to:
src/Matterhorn/State/Messages.hs:344:          selMsgId <- use (csCurrentTeam.tsMessageSelect.to selectMessageId)
src/Matterhorn/State/Messages.hs:367:                csCurrentTeam.tsMessageSelect .= MessageSelectState Nothing
src/Matterhorn/State/Messages.hs:382:                  csCurrentTeam.tsMessageSelect .= MessageSelectState (pure $ MessagePostId earliestPId)
src/Matterhorn/State/Messages.hs:394:                  csCurrentTeam.tsMessageSelect .= MessageSelectState (gapMsg^.mMessageId)
src/Matterhorn/State/Messages.hs:403:                  csCurrentTeam.tsMessageSelect .= MessageSelectState (pure $ MessagePostId latestPId)
src/Matterhorn/State/Messages.hs:415:                  csCurrentTeam.tsMessageSelect .= MessageSelectState (gapMsg^.mMessageId)

Needs to use the team for the channel in which the jumped post is located:
src/Matterhorn/State/Messages.hs:907:                      csCurrentTeam.tsMessageSelect .= MessageSelectState (msg^.mMessageId)

src/Matterhorn/State/ChannelSelect.hs:28:    csCurrentTeam.tsChannelSelectState .= emptyChannelSelectState tId
src/Matterhorn/State/ChannelSelect.hs:33:    zipper <- use (csCurrentTeam.tsFocus)
src/Matterhorn/State/ChannelSelect.hs:35:    csCurrentTeam.tsChannelSelectState.channelSelectMatches %= Z.findRight isCurrentFocus
src/Matterhorn/State/ChannelSelect.hs:49:    input <- use (csCurrentTeam.tsChannelSelectState.channelSelectInput)
src/Matterhorn/State/ChannelSelect.hs:86:    csCurrentTeam.tsChannelSelectState.channelSelectMatches %=
src/Matterhorn/State/ChannelSelect.hs:87:        (Z.updateListBy preserveFocus $ Z.toList $ Z.maybeMapZipper matches (st^.csCurrentTeam.tsFocus))
src/Matterhorn/State/ChannelSelect.hs:157:    csCurrentTeam.tsChannelSelectState.channelSelectMatches %= nextItem

src/Matterhorn/State/ThemeListOverlay.hs:34:    enterListOverlayMode (csCurrentTeam.tsThemeListOverlay)
src/Matterhorn/State/ThemeListOverlay.hs:59:themeListMove = listOverlayMove (csCurrentTeam.tsThemeListOverlay)

src/Matterhorn/State/Editing.hs:69:    csCurrentTeam.tsEditState.cedEphemeral.eesMultiline .= True
src/Matterhorn/State/Editing.hs:74:    csCurrentTeam.tsEditState.cedEphemeral.eesMultiline %= not
src/Matterhorn/State/Editing.hs:81:    multiline <- use (csCurrentTeam.tsEditState.cedEphemeral.eesMultiline)
src/Matterhorn/State/Editing.hs:82:    numLines <- use (csCurrentTeam.tsEditState.cedEditor.to getEditContents.to length)
src/Matterhorn/State/Editing.hs:99:            getEditContents $ st^.csCurrentTeam.tsEditState.cedEditor
src/Matterhorn/State/Editing.hs:115:                        return $ st & csCurrentTeam.tsEditState.cedEditor.editContentsL .~ (Z.textZipper tmpLines Nothing)
src/Matterhorn/State/Editing.hs:121:  csCurrentTeam.tsEditState.cedEditor %= applyEdit (Z.insertMany (sanitizeUserText' pasteStr))
src/Matterhorn/State/Editing.hs:122:  contents <- use (csCurrentTeam.tsEditState.cedEditor.to getEditContents)
src/Matterhorn/State/Editing.hs:129:    (length (getEditContents $ st^.csCurrentTeam.tsEditState.cedEditor) == 1) ||
src/Matterhorn/State/Editing.hs:130:    st^.csCurrentTeam.tsEditState.cedEphemeral.eesMultiline
src/Matterhorn/State/Editing.hs:134:    let KeyHandlerMap m = editingKeybindings (csCurrentTeam.tsEditState.cedEditor) kc
src/Matterhorn/State/Editing.hs:170:      csCurrentTeam.tsEditState.cedYankBuffer .= restOfLine
src/Matterhorn/State/Editing.hs:198:      buf <- use (csCurrentTeam.tsEditState.cedYankBuffer)
src/Matterhorn/State/Editing.hs:204:    cmdLine <- use (csCurrentTeam.tsEditState.cedEditor)
src/Matterhorn/State/Editing.hs:224:    csCurrentTeam.tsEditState.cedEditor %= applyEdit Z.clearZipper
src/Matterhorn/State/Editing.hs:225:    csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition .= Nothing
src/Matterhorn/State/Editing.hs:232:          attachments <- use (csCurrentTeam.tsEditState.cedAttachmentList.L.listElementsL)
src/Matterhorn/State/Editing.hs:233:          mode <- use (csCurrentTeam.tsEditState.cedEditMode)
src/Matterhorn/State/Editing.hs:244:    csCurrentTeam.tsEditState.cedEditMode .= NewPost
src/Matterhorn/State/Editing.hs:265:    beforeLineCount <- use (csCurrentTeam.tsEditState.cedEditor.to getEditContents.to length)
src/Matterhorn/State/Editing.hs:270:    csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition .= Nothing
src/Matterhorn/State/Editing.hs:273:    justCompleted <- use (csCurrentTeam.tsEditState.cedJustCompleted)
src/Matterhorn/State/Editing.hs:276:    let keyMap = editingKeybindings (csCurrentTeam.tsEditState.cedEditor) (configUserKeys conf)
src/Matterhorn/State/Editing.hs:284:            csCurrentTeam.tsEditState.cedEditor %= applyEdit Z.clearZipper
src/Matterhorn/State/Editing.hs:289:              let backspace = csCurrentTeam.tsEditState.cedEditor %= applyEdit Z.deletePrevChar
src/Matterhorn/State/Editing.hs:290:              in case cursorAtOneOf smartChars (st^.csCurrentTeam.tsEditState.cedEditor) of
src/Matterhorn/State/Editing.hs:294:                      if | (cursorAtChar ch $ applyEdit Z.moveLeft $ st^.csCurrentTeam.tsEditState.cedEditor) &&
src/Matterhorn/State/Editing.hs:295:                           (cursorIsAtEnd $ applyEdit Z.moveRight $ st^.csCurrentTeam.tsEditState.cedEditor) ->
src/Matterhorn/State/Editing.hs:296:                             csCurrentTeam.tsEditState.cedEditor %= applyEdit (Z.deleteChar >>> Z.deletePrevChar)
src/Matterhorn/State/Editing.hs:303:                    csCurrentTeam.tsEditState.cedEditor %= applyEdit (Z.insertChar ch)
src/Matterhorn/State/Editing.hs:305:                  curLine = Z.currentLine $ st^.csCurrentTeam.tsEditState.cedEditor.editContentsL
src/Matterhorn/State/Editing.hs:310:              in if | (cursorIsAtEnd $ st^.csCurrentTeam.tsEditState.cedEditor) &&
src/Matterhorn/State/Editing.hs:313:                        csCurrentTeam.tsEditState.cedEditor %= applyEdit (Z.insertMany (T.singleton ch))
src/Matterhorn/State/Editing.hs:314:                        csCurrentTeam.tsEditState.cedEphemeral.eesMultiline .= True
src/Matterhorn/State/Editing.hs:319:                    | (editorEmpty $ st^.csCurrentTeam.tsEditState.cedEditor) ||
src/Matterhorn/State/Editing.hs:320:                         ((cursorAtChar ' ' (applyEdit Z.moveLeft $ st^.csCurrentTeam.tsEditState.cedEditor)) &&
src/Matterhorn/State/Editing.hs:321:                          (cursorIsAtEnd $ st^.csCurrentTeam.tsEditState.cedEditor)) ->
src/Matterhorn/State/Editing.hs:322:                        csCurrentTeam.tsEditState.cedEditor %= applyEdit (Z.insertMany (T.pack $ ch:ch:[]) >>> Z.moveLeft)
src/Matterhorn/State/Editing.hs:327:                    | (cursorAtChar ch $ st^.csCurrentTeam.tsEditState.cedEditor) &&
src/Matterhorn/State/Editing.hs:328:                      (cursorIsAtEnd $ applyEdit Z.moveRight $ st^.csCurrentTeam.tsEditState.cedEditor) ->
src/Matterhorn/State/Editing.hs:329:                        csCurrentTeam.tsEditState.cedEditor %= applyEdit Z.moveRight
src/Matterhorn/State/Editing.hs:339:                  csCurrentTeam.tsEditState.cedEditor %= applyEdit Z.deletePrevChar
src/Matterhorn/State/Editing.hs:341:              csCurrentTeam.tsEditState.cedEditor %= applyEdit (Z.insertMany (sanitizeUserText' $ T.singleton ch))
src/Matterhorn/State/Editing.hs:344:              mhHandleEventLensed (csCurrentTeam.tsEditState.cedEditor) handleEditorEvent e
src/Matterhorn/State/Editing.hs:352:    liftIO $ resetSpellCheckTimer $ st^.csCurrentTeam.tsEditState
src/Matterhorn/State/Editing.hs:358:    afterLineCount <- use (csCurrentTeam.tsEditState.cedEditor.to getEditContents.to length)
src/Matterhorn/State/Editing.hs:359:    isMultiline <- use (csCurrentTeam.tsEditState.cedEphemeral.eesMultiline)
src/Matterhorn/State/Editing.hs:368:        csCurrentTeam.tsEditState.cedJustCompleted .= False
src/Matterhorn/State/Editing.hs:379:        let pId = case st^.csCurrentTeam.tsEditState.cedEditMode of
src/Matterhorn/State/Editing.hs:393:    case st^.csCurrentTeam.tsEditState.cedSpellChecker of
src/Matterhorn/State/Editing.hs:397:            contents <- getEditContents <$> use (csCurrentTeam.tsEditState.cedEditor)
src/Matterhorn/State/Editing.hs:406:                        csCurrentTeam.tsEditState.cedMisspellings .= allMistakes
src/Matterhorn/State/Editing.hs:457:    ac <- use (csCurrentTeam.tsEditState.cedAutocomplete)
src/Matterhorn/State/Editing.hs:462:            mode <- use (csCurrentTeam.tsEditState.cedEditMode)
src/Matterhorn/State/Editing.hs:466:                    csCurrentTeam.tsEditState.cedEditMode .= NewPost
src/Matterhorn/State/Editing.hs:467:                    csCurrentTeam.tsEditState.cedEditor %= applyEdit Z.clearZipper
src/Matterhorn/State/Editing.hs:479:           csCurrentTeam.tsEditState.cedEditMode .= Replying rootMsg (fromJust $ rootMsg^.mOriginalPost)
src/Matterhorn/State/Editing.hs:499:    csCurrentTeam.tsEditState.cedAutocomplete._Just.acCompletionList %= transform
src/Matterhorn/State/Editing.hs:501:    mac <- use (csCurrentTeam.tsEditState.cedAutocomplete)
src/Matterhorn/State/Editing.hs:517:                    csCurrentTeam.tsEditState.cedEditor %=
src/Matterhorn/State/Editing.hs:520:                    csCurrentTeam.tsEditState.cedJustCompleted .= True

src/Matterhorn/State/Autocomplete.hs:64:            prevResult <- use (csCurrentTeam.tsEditState.cedAutocomplete)
src/Matterhorn/State/Autocomplete.hs:77:                csCurrentTeam.tsEditState.cedAutocompletePending .= Just searchString
src/Matterhorn/State/Autocomplete.hs:83:    z <- use (csCurrentTeam.tsEditState.cedEditor.editContentsL)
src/Matterhorn/State/Autocomplete.hs:170:    mCache <- preuse (csCurrentTeam.tsEditState.cedAutocomplete._Just.acCachedResponses)
src/Matterhorn/State/Autocomplete.hs:171:    mActiveTy <- preuse (csCurrentTeam.tsEditState.cedAutocomplete._Just.acType)
src/Matterhorn/State/Autocomplete.hs:311:    mCache <- preuse (csCurrentTeam.tsEditState.cedAutocomplete._Just.acCachedResponses)
src/Matterhorn/State/Autocomplete.hs:312:    mActiveTy <- preuse (csCurrentTeam.tsEditState.cedAutocomplete._Just.acType)
src/Matterhorn/State/Autocomplete.hs:338:    pending <- use (csCurrentTeam.tsEditState.cedAutocompletePending)
src/Matterhorn/State/Autocomplete.hs:344:            csCurrentTeam.tsEditState.cedAutocomplete %= \prev ->

src/Matterhorn/State/Channels.hs:113:    csCurrentTeam.tsFocus %= Z.updateList zl
src/Matterhorn/State/Channels.hs:117:    newZ <- use (csCurrentTeam.tsFocus)
src/Matterhorn/State/Channels.hs:157:               then use (csCurrentTeam.tsRecentChannel)
src/Matterhorn/State/Channels.hs:435:    ch <- use (csCurrentTeam.tsPendingChannelChange)
src/Matterhorn/State/Channels.hs:452:    ch <- use (csCurrentTeam.tsPendingChannelChange)
src/Matterhorn/State/Channels.hs:499:            csCurrentTeam.tsPendingChannelChange .= Nothing
src/Matterhorn/State/Channels.hs:512:                                csCurrentTeam.tsPendingChannelChange .=
src/Matterhorn/State/Channels.hs:524:                                csCurrentTeam.tsPendingChannelChange .=
src/Matterhorn/State/Channels.hs:540:    oldZipper <- use (csCurrentTeam.tsFocus)
src/Matterhorn/State/Channels.hs:552:          csCurrentTeam.tsFocus .= newZipper
src/Matterhorn/State/Channels.hs:576:        Just e -> csCurrentTeam.tsEditState.cedEphemeral .= e
src/Matterhorn/State/Channels.hs:583:    inputHistoryPos <- use (csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition)
src/Matterhorn/State/Channels.hs:587:            (lastEdit, lastEditMode) <- use (csCurrentTeam.tsEditState.cedEphemeral.eesLastInput)
src/Matterhorn/State/Channels.hs:588:            csCurrentTeam.tsEditState.cedEditor %= (applyEdit $ insertMany lastEdit . clearZipper)
src/Matterhorn/State/Channels.hs:589:            csCurrentTeam.tsEditState.cedEditMode .= lastEditMode
src/Matterhorn/State/Channels.hs:599:    csCurrentTeam.tsRecentChannel .= Just cId
src/Matterhorn/State/Channels.hs:604:    csCurrentTeam.tsEditState.cedEditMode .= NewPost
src/Matterhorn/State/Channels.hs:608:clearEditor = csCurrentTeam.tsEditState.cedEditor %= applyEdit clearZipper
src/Matterhorn/State/Channels.hs:614:    oldEphemeral <- use (csCurrentTeam.tsEditState.cedEphemeral)
src/Matterhorn/State/Channels.hs:620:    cmdLine <- use (csCurrentTeam.tsEditState.cedEditor)
src/Matterhorn/State/Channels.hs:621:    mode <- use (csCurrentTeam.tsEditState.cedEditMode)
src/Matterhorn/State/Channels.hs:625:    inputHistoryPos <- use (csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition)
src/Matterhorn/State/Channels.hs:628:        csCurrentTeam.tsEditState.cedEphemeral.eesLastInput .=
src/Matterhorn/State/Channels.hs:731:            csCurrentTeam.tsFocus %= Z.filterZipper ((/= cId) . channelListEntryChannelId)
src/Matterhorn/State/Channels.hs:751:  recent <- use (csCurrentTeam.tsRecentChannel)
src/Matterhorn/State/Channels.hs:755:        ret <- use (csCurrentTeam.tsReturnChannel)
src/Matterhorn/State/Channels.hs:761:  val <- use (csCurrentTeam.tsReturnChannel)
src/Matterhorn/State/Channels.hs:767:          csCurrentTeam.tsReturnChannel .= Nothing
src/Matterhorn/State/Channels.hs:771:  ret <- use (csCurrentTeam.tsReturnChannel)
src/Matterhorn/State/Channels.hs:780:  ret <- use (csCurrentTeam.tsReturnChannel)
src/Matterhorn/State/Channels.hs:785:        csCurrentTeam.tsReturnChannel .= Just cId
src/Matterhorn/State/Channels.hs:903:                          csCurrentTeam.tsPendingChannelChange .=
src/Matterhorn/State/Channels.hs:922:    inputHistoryPos <- use (csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition)
src/Matterhorn/State/Channels.hs:927:            csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition .= Nothing
src/Matterhorn/State/Channels.hs:932:            csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition .= (Just newI)
src/Matterhorn/State/Channels.hs:943:            csCurrentTeam.tsEditState.cedEditor.editContentsL .= (mv $ textZipper eLines Nothing)
src/Matterhorn/State/Channels.hs:950:    inputHistoryPos <- use (csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition)
src/Matterhorn/State/Channels.hs:955:    csCurrentTeam.tsEditState.cedEphemeral.eesInputHistoryPosition .= (Just newI)
src/Matterhorn/State/Channels.hs:1031:isRecentChannel st cId = st^.csCurrentTeam.tsRecentChannel == Just cId
src/Matterhorn/State/Channels.hs:1034:isReturnChannel st cId = st^.csCurrentTeam.tsReturnChannel == Just cId
src/Matterhorn/State/Channels.hs:1062:            csCurrentTeam.tsPendingChannelChange .= (Just $ ChangeByChannelId chanId act)
src/Matterhorn/State/Channels.hs:1078:            csCurrentTeam.tsPendingChannelChange .= (Just $ ChangeByUserId $ user^.uiId)

src/Matterhorn/State/Attachments.hs:37:    lst <- use (csCurrentTeam.tsEditState.cedAttachmentList)
src/Matterhorn/State/Attachments.hs:46:    csCurrentTeam.tsEditState.cedAttachmentList .= L.list listName mempty 1
src/Matterhorn/State/Attachments.hs:55:    csCurrentTeam.tsEditState.cedFileBrowser .= browser

src/Matterhorn/State/MessageSelect.hs:59:        selMsgId <- selectMessageId $ st^.csCurrentTeam.tsMessageSelect
src/Matterhorn/State/MessageSelect.hs:77:        csCurrentTeam.tsMessageSelect .= MessageSelectState (recentMsg >>= _mMessageId)
src/Matterhorn/State/MessageSelect.hs:122:    csCurrentTeam.tsViewedMessage .= Just (m, w)
src/Matterhorn/State/MessageSelect.hs:173:    selected <- use (csCurrentTeam.tsMessageSelect.to selectMessageId)
src/Matterhorn/State/MessageSelect.hs:178:            csCurrentTeam.tsMessageSelect .= MessageSelectState (nextMsgId <|> selected)
src/Matterhorn/State/MessageSelect.hs:183:    selected <- use (csCurrentTeam.tsMessageSelect.to selectMessageId)
src/Matterhorn/State/MessageSelect.hs:188:            csCurrentTeam.tsMessageSelect .= MessageSelectState (nextMsgId <|> selected)
src/Matterhorn/State/MessageSelect.hs:205:    selected <- use (csCurrentTeam.tsMessageSelect.to selectMessageId)
src/Matterhorn/State/MessageSelect.hs:211:                csCurrentTeam.tsMessageSelect .= MessageSelectState (firstMsg^.mMessageId <|> selected)
src/Matterhorn/State/MessageSelect.hs:217:    selected <- use (csCurrentTeam.tsMessageSelect.to selectMessageId)
src/Matterhorn/State/MessageSelect.hs:223:                csCurrentTeam.tsMessageSelect .= MessageSelectState (lastSelMsg^.mMessageId <|> selected)
src/Matterhorn/State/MessageSelect.hs:239:                          csCurrentTeam.tsEditState.cedEditMode .= NewPost
src/Matterhorn/State/MessageSelect.hs:252:            csCurrentTeam.tsEditState.cedEditMode .= Replying rootMsg p
src/Matterhorn/State/MessageSelect.hs:263:            csCurrentTeam.tsEditState.cedEditMode .= Editing p (msg^.mType)
src/Matterhorn/State/MessageSelect.hs:275:            csCurrentTeam.tsEditState.cedEditor %= applyEdit (insertMany toEdit . clearZipper)

src/Matterhorn/State/PostListOverlay.hs:36:  csCurrentTeam.tsPostListOverlay.postListPosts .= msgs
src/Matterhorn/State/PostListOverlay.hs:40:  csCurrentTeam.tsPostListOverlay.postListSelected .= pId
src/Matterhorn/State/PostListOverlay.hs:49:  csCurrentTeam.tsPostListOverlay.postListPosts .= emptyDirSeq
src/Matterhorn/State/PostListOverlay.hs:50:  csCurrentTeam.tsPostListOverlay.postListSelected .= Nothing
src/Matterhorn/State/PostListOverlay.hs:100:  selId <- use (csCurrentTeam.tsPostListOverlay.postListSelected)
src/Matterhorn/State/PostListOverlay.hs:101:  posts <- use (csCurrentTeam.tsPostListOverlay.postListPosts)
src/Matterhorn/State/PostListOverlay.hs:107:      csCurrentTeam.tsPostListOverlay.postListSelected .= pId
src/Matterhorn/State/PostListOverlay.hs:118:  selId <- use (csCurrentTeam.tsPostListOverlay.postListSelected)
src/Matterhorn/State/PostListOverlay.hs:119:  posts <- use (csCurrentTeam.tsPostListOverlay.postListPosts)
src/Matterhorn/State/PostListOverlay.hs:125:      csCurrentTeam.tsPostListOverlay.postListSelected .= pId
src/Matterhorn/State/PostListOverlay.hs:135:  msgId <- use (csCurrentTeam.tsPostListOverlay.postListSelected)
src/Matterhorn/State/PostListOverlay.hs:145:  msgId <- use (csCurrentTeam.tsPostListOverlay.postListSelected)

src/Matterhorn/Scripts.hs:50:                mode <- use (csCurrentTeam.tsEditState.cedEditMode)

src/Matterhorn/State/UrlSelect.hs:27:    csCurrentTeam.tsUrlList .= (listMoveTo (length urls - 1) $ list (UrlList tId) urls 2)
src/Matterhorn/State/UrlSelect.hs:34:    selected <- use (csCurrentTeam.tsUrlList.to listSelectedElement)

src/Matterhorn/State/Flagging.hs:51:              csCurrentTeam.tsPostListOverlay.postListPosts %=
src/Matterhorn/State/Flagging.hs:57:              selId <- use (csCurrentTeam.tsPostListOverlay.postListSelected)
src/Matterhorn/State/Flagging.hs:58:              posts <- use (csCurrentTeam.tsPostListOverlay.postListPosts)
src/Matterhorn/State/Flagging.hs:62:              csCurrentTeam.tsPostListOverlay.postListSelected .= nextId
src/Matterhorn/State/Flagging.hs:63:              csCurrentTeam.tsPostListOverlay.postListPosts %=

src/Matterhorn/State/ChannelListOverlay.hs:32:    enterListOverlayMode (csCurrentTeam.tsChannelListOverlay) ChannelListOverlay
src/Matterhorn/State/ChannelListOverlay.hs:78:channelListMove = listOverlayMove (csCurrentTeam.tsChannelListOverlay)

src/Matterhorn/State/UserListOverlay.hs:85:    csCurrentTeam.tsUserListOverlay.listOverlayRecordCount .= resultCount
src/Matterhorn/State/UserListOverlay.hs:86:    enterListOverlayMode (csCurrentTeam.tsUserListOverlay) UserListOverlay scope enterHandler getUserSearchResults
src/Matterhorn/State/UserListOverlay.hs:114:userListMove = listOverlayMove (csCurrentTeam.tsUserListOverlay)

src/Matterhorn/State/ChannelTopicWindow.hs:19:    csCurrentTeam.tsChannelTopicDialog .= newChannelTopicDialog tId t

src/Matterhorn/Windows/ViewMessage.hs:83:    let latestMessage = case cs^.csCurrentTeam.tsViewedMessage of

src/Matterhorn/Command.hs:278:  em       <- use (csCurrentTeam.tsEditState.cedEditMode)

src/Matterhorn/Types.hs:143:  , csCurrentTeam
src/Matterhorn/Types.hs:1932:    curMode <- use (csCurrentTeam.tsMode)
src/Matterhorn/Types.hs:1937:    csCurrentTeam.tsMode .= m
src/Matterhorn/Types.hs:1941:setMode' m = csCurrentTeam.tsMode .~ m
src/Matterhorn/Types.hs:1954:csCurrentChannelId = csCurrentTeam.tsFocus.to Z.unsafeFocus.to channelListEntryChannelId
src/Matterhorn/Types.hs:1957:csCurrentTeamId = csCurrentTeam.tsTeam.teamIdL
src/Matterhorn/Types.hs:2108:    csCurrentTeam.tsEditState.cedAutocomplete .= Nothing
src/Matterhorn/Types.hs:2109:    csCurrentTeam.tsEditState.cedAutocompletePending .= Nothing

src/Matterhorn/Events/ChannelListOverlay.hs:21:    void . onEventListOverlay (csCurrentTeam.tsChannelListOverlay) channelListOverlayKeybindings
src/Matterhorn/Events/ChannelListOverlay.hs:29:    [ mkKb CancelEvent "Close the channel search list" (exitListOverlay (csCurrentTeam.tsChannelListOverlay))
src/Matterhorn/Events/ChannelListOverlay.hs:34:    , mkKb ActivateListItemEvent "Join the selected channel" (listOverlayActivateCurrent (csCurrentTeam.tsChannelListOverlay))

src/Matterhorn/Events/EditNotifyPrefs.hs:28:            form <- use (csCurrentTeam.tsNotifyPrefs.singular _Just)
src/Matterhorn/Events/EditNotifyPrefs.hs:30:            csCurrentTeam.tsNotifyPrefs .= Just updatedForm
src/Matterhorn/Events/EditNotifyPrefs.hs:41:        let form = fromJust $ st^.csCurrentTeam.tsNotifyPrefs

src/Matterhorn/Events/ThemeListOverlay.hs:16:    void . onEventListOverlay (csCurrentTeam.tsThemeListOverlay)
src/Matterhorn/Events/ThemeListOverlay.hs:26:      (exitListOverlay (csCurrentTeam.tsThemeListOverlay))
src/Matterhorn/Events/ThemeListOverlay.hs:36:      (listOverlayActivateCurrent (csCurrentTeam.tsThemeListOverlay))

src/Matterhorn/Events/UserListOverlay.hs:16:    void . onEventListOverlay (csCurrentTeam.tsUserListOverlay) userListOverlayKeybindings
src/Matterhorn/Events/UserListOverlay.hs:24:    [ mkKb CancelEvent "Close the user search list" (exitListOverlay (csCurrentTeam.tsUserListOverlay))
src/Matterhorn/Events/UserListOverlay.hs:29:    , mkKb ActivateListItemEvent "Interact with the selected user" (listOverlayActivateCurrent (csCurrentTeam.tsUserListOverlay))

src/Matterhorn/Events/Main.hs:81:             isMultiline <- use (csCurrentTeam.tsEditState.cedEphemeral.eesMultiline)
src/Matterhorn/Events/Main.hs:83:                 True -> mhHandleEventLensed (csCurrentTeam.tsEditState.cedEditor) handleEditorEvent
src/Matterhorn/Events/Main.hs:92:             isMultiline <- use (csCurrentTeam.tsEditState.cedEphemeral.eesMultiline)
src/Matterhorn/Events/Main.hs:94:                 True -> mhHandleEventLensed (csCurrentTeam.tsEditState.cedEditor) handleEditorEvent
src/Matterhorn/Events/Main.hs:126:             isMultiline <- use (csCurrentTeam.tsEditState.cedEphemeral.eesMultiline)

src/Matterhorn/Events/ReactionEmojiListOverlay.hs:21:    void . onEventListOverlay (csCurrentTeam.tsReactionEmojiListOverlay)
src/Matterhorn/Events/ReactionEmojiListOverlay.hs:31:      (exitListOverlay (csCurrentTeam.tsReactionEmojiListOverlay))
src/Matterhorn/Events/ReactionEmojiListOverlay.hs:41:      (listOverlayActivateCurrent (csCurrentTeam.tsReactionEmojiListOverlay))

src/Matterhorn/Draw/URLList.hs:39:        urls = st^.csCurrentTeam.tsUrlList

src/Matterhorn/Draw/ThemeListOverlay.hs:26:    let overlay = drawListOverlay (st^.csCurrentTeam.tsThemeListOverlay)

src/Matterhorn/Events/ChannelSelect.hs:20:      handled <- handleKeyboardEvent (editingKeybindings (csCurrentTeam.tsChannelSelectState.channelSelectInput)) (const $ return ()) e
src/Matterhorn/Events/ChannelSelect.hs:22:          mhHandleEventLensed (csCurrentTeam.tsChannelSelectState.channelSelectInput) handleEditorEvent e
src/Matterhorn/Events/ChannelSelect.hs:33:             matches <- use (csCurrentTeam.tsChannelSelectState.channelSelectMatches)

src/Matterhorn/Draw/Autocomplete.hs:27:    case st^.csCurrentTeam.tsEditState.cedAutocomplete of
src/Matterhorn/Draw/Autocomplete.hs:67:               editorOffset = if st^.csCurrentTeam.tsEditState.cedEphemeral.eesMultiline

src/Matterhorn/Events/ChannelTopicWindow.hs:21:    csCurrentTeam.tsChannelTopicDialog.channelTopicDialogFocus %= focusNext
src/Matterhorn/Events/ChannelTopicWindow.hs:23:    csCurrentTeam.tsChannelTopicDialog.channelTopicDialogFocus %= focusPrev
src/Matterhorn/Events/ChannelTopicWindow.hs:25:    f <- use (csCurrentTeam.tsChannelTopicDialog.channelTopicDialogFocus)
src/Matterhorn/Events/ChannelTopicWindow.hs:28:            ed <- use (csCurrentTeam.tsChannelTopicDialog.channelTopicDialogEditor)
src/Matterhorn/Events/ChannelTopicWindow.hs:33:            mhHandleEventLensed (csCurrentTeam.tsChannelTopicDialog.channelTopicDialogEditor)
src/Matterhorn/Events/ChannelTopicWindow.hs:42:    f <- use (csCurrentTeam.tsChannelTopicDialog.channelTopicDialogFocus)
src/Matterhorn/Events/ChannelTopicWindow.hs:45:            mhHandleEventLensed (csCurrentTeam.tsChannelTopicDialog.channelTopicDialogEditor)

src/Matterhorn/State/ReactionEmojiListOverlay.hs:42:            enterListOverlayMode (csCurrentTeam.tsReactionEmojiListOverlay) ReactionEmojiListOverlay
src/Matterhorn/State/ReactionEmojiListOverlay.hs:121:reactionEmojiListMove = listOverlayMove (csCurrentTeam.tsReactionEmojiListOverlay)

src/Matterhorn/Draw/ShowHelp.hs:446:    , ("Text Editing", editingKeyHandlers (csCurrentTeam.tsEditState.cedEditor))
src/Matterhorn/Draw/ShowHelp.hs:453:    , ("Message Viewer: Common", tabbedWindowKeyHandlers (csCurrentTeam.tsViewedMessage.singular _Just._2))

src/Matterhorn/Events/ManageAttachments.hs:42:        mhHandleEventLensed (csCurrentTeam.tsEditState.cedAttachmentList) L.handleListEvent
src/Matterhorn/Events/ManageAttachments.hs:52:          mhHandleEventLensed (csCurrentTeam.tsEditState.cedAttachmentList) L.handleListEvent (V.EvKey V.KUp [])
src/Matterhorn/Events/ManageAttachments.hs:54:          mhHandleEventLensed (csCurrentTeam.tsEditState.cedAttachmentList) L.handleListEvent (V.EvKey V.KDown [])
src/Matterhorn/Events/ManageAttachments.hs:76:    use (csCurrentTeam.tsEditState.cedFileBrowser) >>= \case
src/Matterhorn/Events/ManageAttachments.hs:87:            csCurrentTeam.tsEditState.cedFileBrowser ?= new_b
src/Matterhorn/Events/ManageAttachments.hs:93:    cur <- use (csCurrentTeam.tsEditState.cedAttachmentList.to L.listSelectedElement)
src/Matterhorn/Events/ManageAttachments.hs:123:    es <- use (csCurrentTeam.tsEditState.cedAttachmentList.L.listElementsL)
src/Matterhorn/Events/ManageAttachments.hs:131:  mhHandleEventLensed (csCurrentTeam.tsEditState.cedFileBrowser) fbHandle e
src/Matterhorn/Events/ManageAttachments.hs:138:        es <- use (csCurrentTeam.tsEditState.cedAttachmentList.L.listElementsL)
src/Matterhorn/Events/ManageAttachments.hs:155:                        oldIdx <- use (csCurrentTeam.tsEditState.cedAttachmentList.L.listSelectedL)
src/Matterhorn/Events/ManageAttachments.hs:159:                        csCurrentTeam.tsEditState.cedAttachmentList %= L.listReplace (Vector.snoc es a) newIdx
src/Matterhorn/Events/ManageAttachments.hs:165:    es <- use (csCurrentTeam.tsEditState.cedAttachmentList.L.listElementsL)
src/Matterhorn/Events/ManageAttachments.hs:166:    mSel <- use (csCurrentTeam.tsEditState.cedAttachmentList.to L.listSelectedElement)
src/Matterhorn/Events/ManageAttachments.hs:171:            oldIdx <- use (csCurrentTeam.tsEditState.cedAttachmentList.L.listSelectedL)
src/Matterhorn/Events/ManageAttachments.hs:179:            csCurrentTeam.tsEditState.cedAttachmentList %= L.listReplace (deleteAt pos es) idx

src/Matterhorn/Events/UrlSelect.hs:17:    mhHandleEventLensed (csCurrentTeam.tsUrlList) handleListEvent ev
src/Matterhorn/Events/UrlSelect.hs:31:        mhHandleEventLensed (csCurrentTeam.tsUrlList) handleListEvent (Vty.EvKey Vty.KUp [])
src/Matterhorn/Events/UrlSelect.hs:34:        mhHandleEventLensed (csCurrentTeam.tsUrlList) handleListEvent (Vty.EvKey Vty.KDown [])

src/Matterhorn/Draw/Main.hs:96:    in case st^.csCurrentTeam.tsEditState.cedSpellChecker of
src/Matterhorn/Draw/Main.hs:99:            case S.null (st^.csCurrentTeam.tsEditState.cedMisspellings) of
src/Matterhorn/Draw/Main.hs:103:                           (st^.csCurrentTeam.tsEditState.cedMisspellings)
src/Matterhorn/Draw/Main.hs:227:    let prompt = txt $ case st^.csCurrentTeam.tsEditState.cedEditMode of
src/Matterhorn/Draw/Main.hs:232:        inputBox = renderEditor (drawEditorContents st hs) True (st^.csCurrentTeam.tsEditState.cedEditor)
src/Matterhorn/Draw/Main.hs:233:        curContents = getEditContents $ st^.csCurrentTeam.tsEditState.cedEditor
src/Matterhorn/Draw/Main.hs:238:                                        st^.csCurrentTeam.tsEditState.cedEditor.editContentsL) <>
src/Matterhorn/Draw/Main.hs:245:        replyDisplay = case st^.csCurrentTeam.tsEditState.cedEditMode of
src/Matterhorn/Draw/Main.hs:270:        commandBox = case st^.csCurrentTeam.tsEditState.cedEphemeral.eesMultiline of
src/Matterhorn/Draw/Main.hs:393:            renderMessagesWithSelect (st^.csCurrentTeam.tsMessageSelect) channelMessages
src/Matterhorn/Draw/Main.hs:395:            renderMessagesWithSelect (st^.csCurrentTeam.tsMessageSelect) channelMessages
src/Matterhorn/Draw/Main.hs:460:    let e = st^.csCurrentTeam.tsChannelSelectState.channelSelectInput
src/Matterhorn/Draw/Main.hs:605:                  st^.csCurrentTeam.tsEditState.cedEditor.editContentsL
src/Matterhorn/Draw/Main.hs:607:    overrideTy = case st^.csCurrentTeam.tsEditState.cedEditMode of
src/Matterhorn/Draw/Main.hs:686:        let count = length $ listElements $ st^.csCurrentTeam.tsEditState.cedAttachmentList

src/Matterhorn/Draw/NotifyPrefs.hs:22:    let Just form = st^.csCurrentTeam.tsNotifyPrefs

src/Matterhorn/Draw/PostListOverlay.hs:57:                     (filterMessages knownChannel $ st^.csCurrentTeam.tsPostListOverlay.postListPosts)
src/Matterhorn/Draw/PostListOverlay.hs:103:              matchesMessage (m, _) = m^.mMessageId == (MessagePostId <$> st^.csCurrentTeam.tsPostListOverlay.postListSelected)

src/Matterhorn/Draw/ReactionEmojiListOverlay.hs:20:    let overlay = drawListOverlay (st^.csCurrentTeam.tsReactionEmojiListOverlay)

src/Matterhorn/Draw/ChannelListOverlay.hs:24:    let overlay = drawListOverlay (st^.csCurrentTeam.tsChannelListOverlay) channelSearchScopeHeader

src/Matterhorn/Draw/ChannelList.hs:69:        teamNameStr = sanitizeUserText $ MM.teamDisplayName $ st^.csCurrentTeam.tsTeam
src/Matterhorn/Draw/ChannelList.hs:73:        unreadCount = sum $ (channelListGroupUnread . fst) <$> Z.toList (st^.csCurrentTeam.tsFocus)
src/Matterhorn/Draw/ChannelList.hs:84:                let zipper = st^.csCurrentTeam.tsChannelSelectState.channelSelectMatches
src/Matterhorn/Draw/ChannelList.hs:97:                (renderChannelListGroup st renderEntry <$> Z.toList (st^.csCurrentTeam.tsFocus))

src/Matterhorn/Draw/ManageAttachments.hs:42:       vBox [ renderList renderAttachmentItem True (st^.csCurrentTeam.tsEditState.cedAttachmentList)
src/Matterhorn/Draw/ManageAttachments.hs:64:    FB.renderFileBrowser True $ fromJust (st^.csCurrentTeam.tsEditState.cedFileBrowser)

src/Matterhorn/Draw/UserListOverlay.hs:25:    let overlay = drawListOverlay (st^.csCurrentTeam.tsUserListOverlay) userSearchScopeHeader

src/Matterhorn/Draw/ChannelTopicWindow.hs:51:        foc = st^.csCurrentTeam.tsChannelTopicDialog.channelTopicDialogFocus
src/Matterhorn/Draw/ChannelTopicWindow.hs:52:        ed = st^.csCurrentTeam.tsChannelTopicDialog.channelTopicDialogEditor
